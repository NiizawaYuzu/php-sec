# PHP App ② レビュー

## XSS(クロスサイトスクリプティング)

### XSSとはどんな攻撃か、また攻撃者にどんなメリットがあるか説明してください。
- ユーザのアクセス時に表示内容が生成される動的webページの脆弱性を利用し、HTMLに悪質なスクリプトを埋め込む攻撃です。
サイトに設置されたフォームにユーザが情報を入力・送信する際に、埋められた悪質なHTMLスクリプトが実行され情報が攻撃者に送られる。

### `htmlspecialchars()`を`e()`として定義しなおすメリットを説明してください。
- e()関数として定義しなおすことで、エスケープ処理を何度も記述する必要がなくなるから。

### `htmlspecialchars()`を使うことでなぜXSSが防げるのか説明してください。
- htmlspecialchars()を使うことでエスケープ処理を行い、スクリプト言語等の別の文字列に置き換えて、スクリプトタグなど悪意のあるコードがそのまま実行されてしまうのを防ぐからです。

## CSRF(クロスサイトリクエストフォージェリ)

### CSRFとはどんな攻撃か、また攻撃者にどんなメリットがあるか説明してください。
- CSRFはブラウザを持っている不特定多数に対して意図しないリクエストをさせる攻撃です。
つまり攻撃者は不特定多数に罠（本物そっくりの偽サイト）を張って待ち、引っかかった人に誤ってリクエストを送信させます。攻撃者側のメリットはユーザー側から罠にかかってくるため容易に攻撃ができることです。

### SessionとCookieの違いを説明してください。
- Sessionとは、サーバー側で一時的に保存する仕組みです。
例えばショッピングサイトのカート機能です。複数のページを遷移しカートに追加した商品（情報）を保持します。ブラウザを閉じたら削除されます。

- CookieとはPCなどのブラウザに保存されるwebサイトに関する情報です。
例えばログイン状態の保持などに使用します。
ブラウザを閉じても削除されないです。

### `setToken()`が何をしているか説明してください。
```php
function setToken()
{
    $_SESSION['token'] = bin2hex(openssl_random_pseudo_bytes(16));//ランダム16文字のバイト文字列を作り2進数から16進数に変換した値を$_SESSION['token']に代入
} //bin2hex：stringを16進数に変換した文字列を返す→
```
ワンタイムトークンを作成し、store.phpへのリクエストはnew.php, edit.php, index.php からのみ受け付けるように限定している。

### `checkToken()`が何をしているか説明してください。
```php
function checkToken($token)
{
    if (empty($_SESSION['token']) || ($_SESSION['token'] !== $token)) { //
        $_SESSION['err'] = '不正な操作です';
        redirectToPostedPage();
    }
}
```
`checkToken()`関数は、空のトークンだったり正しくないトークンだった場合、「不正な操作です」と表示する処理をしている。

### トークンを使うことでなぜCSRFが防げるのか説明してください。
- トークンを使うことでHTMLに一意のワンタイムトークンを埋め込み、
再度リクエストするときにそれも送信してもらってリクエスト元が正しいかチェックするため外部のHTMLから送信されることを防きます。


## SQLインジェクション

### SQLインジェクションとはどんな攻撃か、また攻撃者にどんなメリットがあるか説明してください。
- 攻撃側がアプリケーションのセキュリティ上の不備を意図的に利用し、アプリケーションが想定しないSQL文を実行させることで、データベースシステムを不正に操作する攻撃方法です。
具体的には、入力フォームに入力した文字列（内容は別のSQL文）を入力することで、元のSQL文と結合して2つの命令を実行してしまい意図しない処理をしてしまうということです。
これにより攻撃者は、入力フォーム（外部）からDBの操作を容易に行うことができます。

### `->prepare()`の返り値と、またこのメソッドが何をしているか説明してください。
```php
function createTodoData($todoText)
{
    $dbh = connectPdo();
    $sql = 'INSERT INTO todos (content) VALUES (:todoText)'; 
    $stmt = $dbh->prepare($sql); 
    $stmt->bindValue(':todoText', $todoText, PDO::PARAM_STR); 
    $stmt->execute(); 
} 
```
- `->prepare()`の返り値はPDOstatementオブジェクトです。

-  `->prepare()`メソッドは、前のSQL文を引数に入れて実行をする準備をしている。

### `->bindValue()`が何をしているか説明してください。
- ->bindValue()メソッドで、SQL文に入れたプレースホルダーに値をセットしている。
第一引数に対象となる文字列、第二引数に保存したい値、第三引数に保存したいデータ型（文字列）

### 今回の対策でなぜSQLインジェクションが防げるのか説明してください。
- SQLを実行する前に、プレースホルダーを使って入力したデータのデータ型を文字列に限定したことで、
悪意のあるSQL文（例えばレコード全削除する処理など）が文字列として認識され、正常なSQL文が実行されたため。

## バリデーション

### バリデーションの目的について説明してください。
- バリデーションの目的は、ユーザーがフォームに入力した値が運用側が設定した制限通りの内容になっているか確認することです。

### `validate()`が何をしているか説明してください。
- `validate()`関数は、送信されてきた情報が空の場合は「入力がありません」と文言を表示させる処理を行っている。

### `isset($post['content'])`はなぜ必要か、無い場合どうなるか説明してください。
- `isset($post['content'])`関数が必要な理由は、変数が宣言されているか確認するためです。逆に言えば、この関数がない場合未定義の変数によるエラーが起きる可能性がある。

## その他

### `unsetError()`を実行しないとどうなるか説明してください。
sessionのキーであるerrに格納したエラーメッセージを空文字にしないので、ブラウザ上にエラーメッセージが表示される。

